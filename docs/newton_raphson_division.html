<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <meta name="author" content="Shreeyash Pandey">
    <meta name="description" content="Shreeyash's Blog">
    <link rel="alternate" href="/atom.xml" type="application/atom+xml">
    <link rel="stylesheet" href="/style.css" type="text/css">
    <title>Faster Division With Newton-Raphson Approximation | Shreeyash's Blog</title>
  </head>

  <body>
    <header>
      <h1><a href="/">Thoughts, et cetera.</a></h1>
      <nav>
        <h2>Shreeyash's Blog</h2>
        <ul>
          <li><h2><a href="/">Blog</a></h2></li>
          <li><h2><a href="/archive.html">Archive</a></h2></li>
          <li><h2><a href="/tags/">Tags</a></h2></li>
          <li><h2><a href="/links.html">Links</a></h2></li>
          <li><h2><a href="/about.html">About Me</a></h2></li>
        </ul>
      </nav>
    </header>

    <main>
    

  
  <h2>Faster Division With Newton-Raphson Approximation</h2>
  

  <aside>
    <p>published on 2025-10-04

    
    Â· tagged with
      
        <a href="/tags/cs.html">#cs</a>
    
    </p>
  </aside>

  <p>Many devices, especially embedded (micro-controllers and the like) do not come
with an <a href="https://en.wikipedia.org/wiki/Floating-point_unit">FPU</a> and the
circuitry required for carrying out integer division. In such a case, one looks
towards methods of approximating the results of division and storing them in
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">Fixed Point</a> format.</p>
<p>C has standardized support for such an instance via its stdfix library. The <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c051126_ISO_IEC_TR_18037_2008.zip">ISO
Document</a>
describes the data types and functions available in <code>stdfix.h</code>.</p>
<p>This post describes the theory, provides a dependency-free C++ implementation of
the core algorithm and discusses optimizations to speed it up even further. In
that order.</p>
<h2>Theory</h2>
<p>The problem at hand is that of division:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>&#x0003D;</mo><mfrac><mrow><mi>N</mi></mrow><mrow><mi>D</mi></mrow></mfrac></mrow></math>
<p>The first step to solving this is to split the problem in two: Reciprocal
calculation, followed by multiplication. This is what it looks like:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>&#x0003D;</mo><mi>N</mi><mi>&#x000B7;</mi><mrow><mo fence="true" form="prefix" stretchy="true">&#x00028;</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>D</mi></mrow></mfrac><mo fence="true" form="postfix" stretchy="true">&#x00029;</mo></mrow></mrow></math>
<p>It is assumed that the device has a fast multiplication hardware (which is
mostly the case). Thus, multiplication can be carried out by the good ol&rsquo; <code>mul</code>
instruction. Now for the most tricky part - calculating the reciprocal - which
is a division operation!</p>
<p>As it turns out, this is a known problem and solutions are <em>approximately</em> <a href="http://degiorgi.math.hr/aaa_sem/Div/702-706.pdf">as
old as</a> the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix
epoch</a>.</p>
<h3>Newton-Raphson Method</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Division_algorithm#Newton%E2%80%93Raphson_division">Wikipedia
article</a>
sufficiently describes <em>what</em> and <em>how</em> of the NR Method. I&rsquo;ll summarize and add some
missing context.</p>
<p>&ldquo;<a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton&rsquo;s Method</a> is a
root-finding algorithm which produces successively better approximations to the
roots (or zeroes) of a real-valued function.&rdquo; This is the generic iterative
equation according to Newton&rsquo;s method:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo>&#x0003D;</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&#x02212;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">&#x00029;</mo></mrow><mrow><msup><mi>f</mi><mi>&#x02032;</mi></msup><mo stretchy="false">&#x00028;</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">&#x00029;</mo></mrow></mfrac></mrow></math>
<p>The idea is to find a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> for which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x0003D;</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>D</mi></mrow></mfrac></mrow></math> is zero. One such
function is:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>x</mi></mrow></mfrac><mo>&#x02212;</mo><mi>D</mi></mrow></math>
<p>(Substitue <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x0003D;</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>D</mi></mrow></mfrac></mrow></math> in the above equation and it should result in zero)</p>
<p>Next, we find <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>f</mi><mi>&#x02032;</mi></msup><mo stretchy="false">&#x00028;</mo><mi>x</mi><mo stretchy="false">&#x00029;</mo></mrow></math> and substitue it in the NM equation to give us an equation
that allows successive improvements.</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo>&#x0003D;</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&#x02212;</mo><mfrac><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>&#x02212;</mo><mi>D</mi></mrow><mrow><mo>&#x02212;</mo><mfrac><mrow><mn>1</mn></mrow><mrow><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup></mrow></mfrac></mrow></mfrac><mo>&#x0003D;</mo><msub><mi>x</mi><mi>i</mi></msub><mi>&#x000B7;</mi><mrow><mo fence="true" form="prefix" stretchy="true">&#x00028;</mo><mn>2</mn><mo>&#x02212;</mo><mi>D</mi><msub><mi>x</mi><mi>i</mi></msub><mo fence="true" form="postfix" stretchy="true">&#x00029;</mo></mrow></mrow></math>
<p>Astute readers will notice that the result <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub></mrow></math> depends on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></math> (the
previous iteration) i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow></math> depends on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow></math> depends on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow></math>
How do we calculate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow></math>? This is the problem of initial approximation.</p>
<h3>Initial Approximation to the Reciprocal</h3>
<p>Lest the curtain be drawn too soon, here is the final equation for calculating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow></math>, provided <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math> has been scaled to be in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mn>0.5</mn><mo>&#x0002C;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math>:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&#x0003D;</mo><mfrac><mrow><mn>48</mn></mrow><mrow><mn>17</mn></mrow></mfrac><mo>&#x02212;</mo><mfrac><mrow><mn>32</mn></mrow><mrow><mn>17</mn></mrow></mfrac><mi>D</mi></mrow></math>
<p>This equation is a <strong>linear</strong>, <strong>smooth</strong>, and <strong>non-periodic</strong> function. In
numerical algorithms like division, the goal is not necessarily the smallest
average error, but guaranteeing the <strong>worst-case error</strong> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x0007C;</mi><msub><mi>&#x003F5;</mi><mn>0</mn></msub><mi>&#x0007C;</mi></mrow></math>) is as small as possible. This predictability is important because the
initial error directly determines the number of Newton-Raphson iterations
required to reach full machine precision.</p>
<p>We wish to calculate an approximation for the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x0002F;</mo><mi>D</mi></mrow></math> such that the
worst-case error is minimal. The right tool for this job is the <a href="https://en.wikipedia.org/wiki/Equioscillation_theorem">Chebyshev
Equioscillation Theorem</a>.</p>
<p>Chebyshev approximation is used because it provides the <strong>Best Uniform
Approximation</strong> (or Minimax Approximation). This means that out of all possible
polynomials of a given degree, the Chebyshev method yields the one that
minimizes the maximum absolute error across the entire target interval.</p>
<p>We start by formulating the error function on which equioscillation will be
applied. The error function for figuring out the reciprocal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&#x0003D;</mo><mn>1</mn><mo>&#x0002F;</mo><mi>D</mi></mrow></math> using a
simple straight line <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&#x0003D;</mo><msub><mi>T</mi><mn>0</mn></msub><mo>&#x0002B;</mo><msub><mi>T</mi><mn>1</mn></msub><mi>&#x000B7;</mi><mi>D</mi></mrow></math> (a linear equation) tells us how
far off our guess is from the perfect answer. Because we want the total result
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mi>&#x000B7;</mi><msub><mi>x</mi><mn>0</mn></msub></mrow></math> to be near <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn></mrow></math>, we make the error function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>D</mi><mo stretchy="false">&#x00029;</mo></mrow></math> measure the
difference between that product and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn></mrow></math>. The formula is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>D</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mn>1</mn><mo>&#x02212;</mo><mi>D</mi><mi>&#x000B7;</mi><msub><mi>x</mi><mn>0</mn></msub></mrow></math>. When we plug in the straight-line guess, the formula becomes:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>D</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mn>1</mn><mo>&#x02212;</mo><msub><mi>T</mi><mn>0</mn></msub><mi>D</mi><mo>&#x02212;</mo><msub><mi>T</mi><mn>1</mn></msub><msup><mi>D</mi><mn>2</mn></msup></mrow></math>
<p>The main goal is to pick the numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow></math> that minimize the absolute
value of this error <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>D</mi><mo stretchy="false">&#x00029;</mo></mrow></math> everywhere in the range. This is exactly what the
Chebyshev method does.</p>
<p>Before we apply the theorem on the error equation, we need to constrain the
values that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math> can take. Bounding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math> guarantees that the starting error is
small enough for the subsequent iterations to converge quickly and predictably
to full fixed-point precision. Without this bound, a much more complex,
higher-degree polynomial would be needed, defeating the efficiency goal. We
bound <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math> to be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mn>0.5</mn><mo>&#x0002C;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></math>. In code, this scaling can be achieved through simple
bit-shifts. As long as we scale the numerator too, the result remains correct.</p>
<p>The theorem states that a polynomial is the best uniform approximation to a
continuous function over an interval if and only if the error function
alternates between its maximum positive and maximum negative values at least
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">&#x00028;</mo><mi>n</mi><mo>&#x0002B;</mo><mn>2</mn><mo stretchy="false">&#x00029;</mo></mrow></math> times, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math> is the degree of the polynomial. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>&#x0003D;</mo><mn>1</mn></mrow></math> (linear
approximation), we need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x0002B;</mo><mn>2</mn><mo>&#x0003D;</mo><mn>3</mn></mrow></math> alternating extrema: at the two endpoints
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mo>&#x0003D;</mo><mn>1</mn><mo>&#x0002F;</mo><mn>2</mn></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mo>&#x0003D;</mo><mn>1</mn></mrow></math>) and the local extremum (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>D</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math>) between them.</p>
<p>The location of the local extremum is found by setting the derivative to zero:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>f</mi><mi>&#x02032;</mi></msup><mo stretchy="false">&#x00028;</mo><mi>D</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mo>&#x02212;</mo><msub><mi>T</mi><mn>0</mn></msub><mo>&#x02212;</mo><mn>2</mn><msub><mi>T</mi><mn>1</mn></msub><mi>D</mi><mo>&#x0003D;</mo><mn>0</mn><mo>&#x0002C;</mo><mtext>&#x000A0;which&#x000A0;gives:&#x000A0;</mtext><msub><mi>D</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mfrac><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><mrow><mn>2</mn><msub><mi>T</mi><mn>1</mn></msub></mrow></mfrac></mrow></math>
<p>The first condition of the theorem is that the error magnitude is equal at
endpoints, i.e., <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo>&#x0002F;</mo><mn>2</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mi>f</mi><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x02212;</mo><mfrac><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><mrow><mn>2</mn></mrow></mfrac><mo>&#x02212;</mo><mfrac><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><mrow><mn>4</mn></mrow></mfrac><mo>&#x0003D;</mo><mn>1</mn><mo>&#x02212;</mo><msub><mi>T</mi><mn>0</mn></msub><mo>&#x02212;</mo><msub><mi>T</mi><mn>1</mn></msub></mrow></math>
<p>This simplifies to:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mfrac><mrow><mn>3</mn></mrow><mrow><mn>2</mn></mrow></mfrac><msub><mi>T</mi><mn>1</mn></msub></mrow></math>
<p>The second condition states that the error at endpoints must be the negative of
the error at the extremum, i.e., <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mo>&#x02212;</mo><mi>f</mi><mo stretchy="false">&#x00028;</mo><msub><mi>D</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x02212;</mo><msub><mi>T</mi><mn>0</mn></msub><mo>&#x02212;</mo><msub><mi>T</mi><mn>1</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mrow><mo fence="true" form="prefix" stretchy="true">&#x00028;</mo><mn>1</mn><mo>&#x02212;</mo><msub><mi>T</mi><mn>0</mn></msub><msub><mi>D</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>&#x02212;</mo><msub><mi>T</mi><mn>1</mn></msub><msubsup><mi>D</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mn>2</mn></msubsup><mo fence="true" form="postfix" stretchy="true">&#x00029;</mo></mrow></mrow></math>
<p>Substituting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>D</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></math> and simplifying:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x02212;</mo><msub><mi>T</mi><mn>0</mn></msub><mo>&#x02212;</mo><msub><mi>T</mi><mn>1</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mrow><mo fence="true" form="prefix" stretchy="true">&#x00028;</mo><mn>1</mn><mo>&#x0002B;</mo><mfrac><mrow><msubsup><mi>T</mi><mn>0</mn><mn>2</mn></msubsup></mrow><mrow><mn>4</mn><msub><mi>T</mi><mn>1</mn></msub></mrow></mfrac><mo fence="true" form="postfix" stretchy="true">&#x00029;</mo></mrow></mrow></math>
<p>Substituting the value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow></math> from above:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x02212;</mo><mrow><mo fence="true" form="prefix" stretchy="true">&#x00028;</mo><mo>&#x02212;</mo><mfrac><mrow><mn>3</mn></mrow><mrow><mn>2</mn></mrow></mfrac><msub><mi>T</mi><mn>1</mn></msub><mo fence="true" form="postfix" stretchy="true">&#x00029;</mo></mrow><mo>&#x02212;</mo><msub><mi>T</mi><mn>1</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mn>1</mn><mo>&#x02212;</mo><mfrac><mrow><mo stretchy="false">&#x00028;</mo><mo>&#x02212;</mo><mn>3</mn><mo>&#x0002F;</mo><mn>2</mn><mi>&#x000B7;</mi><msub><mi>T</mi><mn>1</mn></msub><msup><mo stretchy="false">&#x00029;</mo><mn>2</mn></msup></mrow><mrow><mn>4</mn><msub><mi>T</mi><mn>1</mn></msub></mrow></mfrac><mn>1</mn><mo>&#x0002B;</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><msub><mi>T</mi><mn>1</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mn>1</mn><mo>&#x02212;</mo><mfrac><mrow><mn>9</mn><msub><mi>T</mi><mn>1</mn></msub></mrow><mrow><mn>16</mn></mrow></mfrac></mrow></math>
<p>Solving this linear equation for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow></math>:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn><mo>&#x0003D;</mo><mo>&#x02212;</mo><mfrac><mrow><mn>17</mn><msub><mi>T</mi><mn>1</mn></msub></mrow><mrow><mn>16</mn></mrow></mfrac><msub><mi>T</mi><mn>1</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mfrac><mrow><mn>32</mn></mrow><mrow><mn>17</mn></mrow></mfrac></mrow></math>
<p>Substituting <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow></math> back into the original equation to find <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow></math>:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>&#x0003D;</mo><mo>&#x02212;</mo><mfrac><mrow><mn>3</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mi>&#x000B7;</mi><mrow><mo fence="true" form="prefix" stretchy="true">&#x00028;</mo><mo>&#x02212;</mo><mfrac><mrow><mn>32</mn></mrow><mrow><mn>17</mn></mrow></mfrac><mo fence="true" form="postfix" stretchy="true">&#x00029;</mo></mrow><msub><mi>T</mi><mn>0</mn></msub><mo>&#x0003D;</mo><mfrac><mrow><mn>48</mn></mrow><mrow><mn>17</mn></mrow></mfrac></mrow></math>
<p>The resulting linear approximation is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&#x0003D;</mo><msub><mi>T</mi><mn>0</mn></msub><mo>&#x0002B;</mo><msub><mi>T</mi><mn>1</mn></msub><mi>D</mi></mrow></math>:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&#x0003D;</mo><mfrac><mrow><mn>48</mn></mrow><mrow><mn>17</mn></mrow></mfrac><mo>&#x02212;</mo><mfrac><mrow><mn>32</mn></mrow><mrow><mn>17</mn></mrow></mfrac><mi>D</mi></mrow></math>
<p>This equation gives the optimal initial estimate for the reciprocal that can be
refined by iterations of the Newton-Raphson equation.</p>
<h2>Implementation</h2>
<p>(For convenience, here&rsquo;s a
<a href="https://gist.github.com/bojle/60f9f9c0a7b0678a2f6b51553217ab6a">link</a> to the
complete implementation)</p>
<p>The original rationale for this implementation was two-fold:</p>
<ol>
<li><strong>Lack of division circuitry.</strong></li>
<li><strong>Lack of support for floating point types.</strong></li>
</ol>
<p>Lack of division circuitry is solved by the algorithm design (reciprocal
multiplication). Lack of floating point types is dealt with by using
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">Fixed-Point notation</a>.
Fixed point allows storing everything in integers and operating using
<strong>bit-shift operations</strong>, which are highly cost-efficient on embedded hardware.</p>
<p>Here&rsquo;s an implementation of a fixed-point type in C++:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdint&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;numeric&gt;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">FRAC_BITS</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TOTAL_BITS</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FixedPoint</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BaseType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">([]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">TOTAL_BITS</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kt">int8_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">TOTAL_BITS</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kt">int16_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">TOTAL_BITS</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kt">int32_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kt">int64_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}());</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">WideType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BaseType</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="kt">int64_t</span><span class="p">,</span><span class="w"> </span><span class="n">__int128_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">BaseType</span><span class="w"> </span><span class="n">SCALE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1ULL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">FRAC_BITS</span><span class="p">);</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">round</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">SCALE</span><span class="p">)))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">BaseType</span><span class="w"> </span><span class="n">raw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="n">BaseType</span><span class="w"> </span><span class="n">rawVal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">FixedPoint</span><span class="w"> </span><span class="n">fp</span><span class="p">;</span>
<span class="w">        </span><span class="n">fp</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rawVal</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">toFloat</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">SCALE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">WideType</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">WideType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prod</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">FRAC_BITS</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">factor</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FixedPoint</span><span class="p">(</span><span class="n">toFloat</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factor</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fp</span><span class="p">.</span><span class="n">toFloat</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>The template parameters specify the fractional and total bit lengths. For
example, <code>FixedPoint&lt;8, 16&gt;</code> uses a 16-bit integer with the scale <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow></math>. The
central idea is that all operations are performed on the integer directly, and
conversion involves scaling and de-scaling with the constant scale value.</p>
<p>The division function below implements the 4-part process: <strong>Normalization</strong>,
<strong>Initial Approximation</strong>, <strong>NR Iterations</strong>, and <strong>Multiplication with
Numerator</strong>. We use the higher precision <code>FixedPoint&lt;16, 32&gt;</code>
(<code>Fx16_32</code>) for intermediate calculations to minimize approximation
error before truncating to the final <code>Fx8_16</code> result.</p>
<div class="codehilite"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">Fx8_16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FixedPoint</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Fx16_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FixedPoint</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">Fx8_16</span><span class="w"> </span><span class="nf">fxdiv_corrected</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Divide by zero undefined&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fx8_16</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">result_is_negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// 1. Normalization/scaling &#39;d&#39; to fit between 0.5 and 1.0</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">countl_zero</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dv</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">scaled_val_raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">scaled_val_n_raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nv</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">INTERPRETATION_SHIFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">d_scaled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fx16_32</span><span class="o">::</span><span class="n">fromRaw</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scaled_val_raw</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">INTERPRETATION_SHIFT</span><span class="p">));</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">n_scaled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fx16_32</span><span class="o">::</span><span class="n">fromRaw</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scaled_val_n_raw</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">INTERPRETATION_SHIFT</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// 2. Initial approximate calculation (Chebyshev: X0 = 48/17 - 32/17 * D)</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="mf">2.8235294f</span><span class="p">};</span><span class="w"> </span><span class="c1">// 48/17</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="mf">1.8823529f</span><span class="p">};</span><span class="w"> </span><span class="c1">// 32/17</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">initial_approx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d_scaled</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 3. Newton-Raphson iterations</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_approx</span><span class="p">;</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="c1">// E1: Precision ~8 bits</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="c1">// E2: Precision ~16 bits (sufficient for Fx16_32)</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="c1">// E3: Conservative overkill</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="c1">// E4: Conservative overkill</span>

<span class="w">    </span><span class="c1">// 4. Multiplication with Numerator</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">res_16_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result_is_negative</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Simple negation</span>
<span class="w">        </span><span class="n">res_16_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res_16_32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Truncate from Fx16_32 (FRAC_BITS=16) to Fx8_16 (FRAC_BITS=8)</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TRUNCATION_SHIFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Shift the raw 32-bit value right by 8 bits to change the binary point position</span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">raw_final_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res_16_32</span><span class="p">.</span><span class="n">raw</span><span class="p">();</span>
<span class="w">    </span><span class="kt">int16_t</span><span class="w"> </span><span class="n">raw_final_16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw_final_32</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">TRUNCATION_SHIFT</span><span class="p">);</span>

<span class="w">    </span><span class="n">Fx8_16</span><span class="w"> </span><span class="n">final_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fx8_16</span><span class="o">::</span><span class="n">fromRaw</span><span class="p">(</span><span class="n">raw_final_16</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">final_res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>The <code>INTERPRETATION_SHIFT</code> and <code>TRUNCATION_SHIFT</code> variables account for
correctly aligning the binary point.</p>
<ul>
<li>The <code>INTERPRETATION_SHIFT</code> (31 - 16 = 15) adjusts the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mn>1.31</mn></mrow></math> normalized
    input to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mn>15.16</mn></mrow></math> format used for calculation, ensuring the value is
interpreted as being in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mn>0.5</mn><mo>&#x0002C;</mo><mn>1.0</mn><mo stretchy="false">]</mo></mrow></math>.</li>
<li>The <code>TRUNCATION_SHIFT</code> (16 - 8 = 8) reduces the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mn>15.16</mn></mrow></math> result to the
    final <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mn>7.8</mn></mrow></math> output format, discarding the lower 8 fractional bits.</li>
</ul>
<p>The code is compiled and run with an example:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">Fx8_16</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fxdiv_corrected</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Approximate division of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Real division of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>clang++<span class="w"> </span>fixed_div.cpp<span class="w"> </span>-o<span class="w"> </span>a<span class="w"> </span>-std<span class="o">=</span>c++20
$<span class="w"> </span>./a
Approximate<span class="w"> </span>division<span class="w"> </span>of<span class="w"> </span><span class="m">3</span>/4:<span class="w"> </span><span class="m">0</span>.74609375
Real<span class="w"> </span>division<span class="w"> </span>of<span class="w"> </span><span class="m">3</span>/4:<span class="w"> </span><span class="m">0</span>.75
</code></pre></div>

<p>The result <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0.74609375</mn></mrow></math> is produced. The error is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x0007C;</mi><mn>0.75</mn><mo>&#x02212;</mo><mn>0.74609375</mn><mi>&#x0007C;</mi><mo>&#x0003D;</mo><mn>0.00390625</mn></mrow></math>. This error is precisely <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mn>2</mn><mrow><mo>&#x02212;</mo><mn>8</mn></mrow></msup></mrow></math>, confirming that the final
precision is limited by the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mn>7.8</mn></mrow></math> output format&rsquo;s smallest bit, which is a key
design feature of fixed-point systems. In fact, the number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0.00390625</mn></mrow></math> has a
name: <a href="https://en.wikipedia.org/wiki/Unit_in_the_last_place">ULP</a>. Due to our
use of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mn>7.8</mn></mrow></math> as the resultant type, it is impossible to precisely express
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0.75</mn></mrow></math>. What we can express is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0.75</mn><mo>&#x02212;</mo><mi>U</mi><mi>L</mi><mi>P</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>0.75</mn><mo>&#x0002B;</mo><mi>U</mi><mi>L</mi><mi>P</mi></mrow></math>
</p>
<h2>Optimizations</h2>
<h3>Power-of-Two Denominator Shortcut</h3>
<p>When the denominator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi></mrow></math> is a power of two (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x000B1;</mi><msup><mn>2</mn><mi>k</mi></msup></mrow></math>), the division <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi><mo>&#x0002F;</mo><mi>D</mi></mrow></math>
simplifies to a <strong>bit shift</strong>. This avoids the computationally expensive
Newton-Raphson (NR) iterative loop entirely. The check to detect if an integer
is a power of 2 can be performed in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x1D4AA;</mi><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo></mrow></math> time, providing a major
speed increase for such common cases.</p>
<h3>Exploiting Quadratic Convergence</h3>
<p>One property of NR iteration is <strong>Quadratic Convergence</strong>. Every iteration
approximately doubles the number of correct bits in the result.</p>
<p>The optimization involves determining the required number of iterations based on
the fractional length of the resultant type. For a required precision of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>16</mn></mrow></math>
fractional bits (as in the <code>Fx16_32</code> intermediate type), only two
iterations are mathematically necessary after the initial approximation.
<a href="https://en.cppreference.com/w/cpp/language/if.html"><code>constexpr if</code></a> statements
can be used to compile-time check the required precision and eliminate
unnecessary NR iterations, ensuring no runtime performance penalty.</p>
<h3>Alternative Initial Approximation Methods</h3>
<p>While the Chebyshev approximation provides the optimal minimax error for the
initial guess, alternative methods exist:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Remez_algorithm"><strong>Remez Algorithm:</strong></a> Can
  generate even better approximations using a higher-degree polynomial. The
trade-off is higher initial calculation complexity for the potential benefit of
requiring fewer subsequent NR iterations.</li>
<li><strong>Look-up Tables (LUTs) and Magic Constants:</strong> <a href="https://dl.acm.org/doi/pdf/10.1145/3708472">Recent
  research</a> shows that pre-computed
LUTs combined with constants can speed up the initial reciprocal approximation.</li>
<li><a href="https://en.wikipedia.org/wiki/CORDIC"><strong>CORDIC (Coordinate Rotation Digital
  Computer):</strong></a> An alternative iterative
technique that can calculate division and other trigonometric functions using
only additions and shifts. It offers competitive performance in some hardware
environments.</li>
</ul>
<h2>Conclusion</h2>
<p>This article came into being after I spent around a month trying to understand
approximation methods and getting code for it to work. The actual code was
contributed to the <a href="https://github.com/llvm/llvm-project/">llvm-project</a> as an
addition to the stdfix library in the llvm libc project. Here is the
<a href="https://github.com/llvm/llvm-project/pull/154914">PR</a>.
<a href="https://github.com/llvm/llvm-project/blob/7eee67202378932d03331ad04e7d07ed4d988381/libc/src/__support/fixed_point/fx_bits.h#L242">Here&rsquo;s</a>
a link to the complete division function implemented with stdfix primitives and
the optimizations mentioned above.</p>


    </main>

    <footer>
      <p>This website was built with <a href="https://github.com/venthur/blag">blag</a>.
      <br>
      Subscribe to the <a href="/atom.xml">atom feed</a>.
      <br>
      Â© 2025, Shreeyash Pandey 
      </p>
    </footer>
  </body>

</html>