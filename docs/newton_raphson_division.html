<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <meta name="author" content="Shreeyash Pandey">
    <meta name="description" content="Shreeyash's Blog">
    <link rel="alternate" href="/atom.xml" type="application/atom+xml">
    <link rel="stylesheet" href="/style.css" type="text/css">
    <title>Faster Division With Newton-Raphson Approximation | Shreeyash's Blog</title>
  </head>

  <body>
    <header>
      <h1><a href="/">Thoughts, et cetera.</a></h1>
      <nav>
        <h2>Shreeyash's Blog</h2>
        <ul>
          <li><h2><a href="/">Blog</a></h2></li>
          <li><h2><a href="/archive.html">Archive</a></h2></li>
          <li><h2><a href="/tags/">Tags</a></h2></li>
          <li><h2><a href="/links.html">Links</a></h2></li>
          <li><h2><a href="/about.html">About Me</a></h2></li>
        </ul>
      </nav>
    </header>

    <main>
    

  
  <h2>Faster Division With Newton-Raphson Approximation</h2>
  

  <aside>
    <p>published on 2025-10-04

    
    · tagged with
      
        <a href="/tags/cs.html">#cs</a>
    
    </p>
  </aside>

  <p>Many devices, especially embedded devices (micro-controllers and the like) do
not come with an <a href="https://en.wikipedia.org/wiki/Floating-point_unit">FPU</a> and
circuitry required for carrying out integer division. In such a case, one looks
towards methods of approximating the results of division and storing them in
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">Fixed Point</a> format.</p>
<p>C has standardized support for such an instance via its stdfix library. The <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c051126_ISO_IEC_TR_18037_2008.zip">ISO
Document</a>
describes the data types and functions available in <code>stdfix.h</code>.</p>
<p>This post describes the theory, provides a dependency-free C++ implementation of
the core algorithm and discusses optimizations to speed it up even further. In
that order.</p>
<h2>Theory</h2>
<p>The problem at hand is that of division:</p>
<div class="codehilite"><pre><span></span><code>C = N/D
</code></pre></div>

<p>The first step to solving this is to split the problem in two: Reciprocal
calculation, followed by multiplication. This is what it looks like:</p>
<div class="codehilite"><pre><span></span><code>C = N * (1/D)
</code></pre></div>

<p>It is assumed that the device has a fast multiplication hardware (which is
mostly the case). Thus, multiplication can be carried out by the good old <code>mul</code>
instruction. Now for the most tricky part - calculating the reciprocal - which
is a division operation!</p>
<p>As it turns out, this is a known problem and solutions are <em>approximately</em> <a href="http://degiorgi.math.hr/aaa_sem/Div/702-706.pdf">as
old as</a> the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix
epoch</a>.</p>
<h3>Newton-Raphson Method</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Division_algorithm#Newton%E2%80%93Raphson_division">Wikipedia
article</a>
suffiecienty describes <em>what</em> and <em>how</em> of the NR Method. I&rsquo;ll summarize and add some
missing context to make it digestable. </p>
<p>&ldquo;<a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton&rsquo;s Method</a> is a
root-finding algorithm which produces successively better approximations to the
roots (or zeroes) of a real-valued function.&rdquo; This is the generic iterative
equation according to Newton&rsquo;s method:</p>
<h3 align="center">
<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mrow><mn>1</mn><mo>&#xA0;</mo></mrow></msub><mo>=</mo><mo>&#xA0;</mo><msub><mi>x</mi><mrow><mn>0</mn><mo>&#xA0;</mo></mrow></msub><mo>-</mo><mo>&#xA0;</mo><mfrac><mrow><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>)</mo></mrow><mrow><mi>f</mi><mo>'</mo><mo>(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>)</mo></mrow></mfrac><mo>&#xA0;</mo><mo>&#xA0;</mo></math>
</h3>

<p>The idea is to find a function <code>f(x)</code> for which <code>x = 1/D</code> is zero. One such
function is:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><mo>(</mo><mn>1</mn><mo>/</mo><mi>x</mi><mo>)</mo><mo>&#xA0;</mo><mo>-</mo><mo>&#xA0;</mo><mi>D</mi></math>

<p>(Substitue <code>x = 1/D</code> in the above equation and it should result in zero)</p>
<p>Next, we find <code>f'(x)</code> and substitue it in the NM equation to give us an equation
that allows successive improvements.</p>
<h3 align="center">
<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&#xA0;</mo><mo>=</mo><mo>&#xA0;</mo><msub><mi>x</mi><mi>i</mi></msub><mo>-</mo><mfrac><mrow><mn>1</mn><mo>/</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&#xA0;</mo><mo>-</mo><mo>&#xA0;</mo><mi>D</mi></mrow><mrow><mo>-</mo><mn>1</mn><mo>/</mo><msup><msub><mi>x</mi><mi>i</mi></msub><mn>2</mn></msup></mrow></mfrac><mo>&#xA0;</mo><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&#xA0;</mo><mo>(</mo><mn>2</mn><mo>&#xA0;</mo><mo>-</mo><mo>&#xA0;</mo><mi>D</mi><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo></math>
</h3>

<p>Astute readers will notice that the result <code>x₂</code> (result of the second iteration)
depends on <code>x₁</code> and<code>x₁</code> (result of the first iteration) depends on <code>x₀</code>. How do
we calculate <code>x₀</code>? This is the problem of initial approximation.</p>
<h3>Initial Approximation to the Reciprocal</h3>
<p>Lest the curtain be drawn too soon, here&rsquo;s the final equation for calculating
<code>x₀</code>, provided <code>D</code> has been scaled to be in the range <code>[0.5,1]</code></p>
<div class="codehilite"><pre><span></span><code>x₀ = 48/17 - 32/17 * D
</code></pre></div>

<p>We notice that the equation at hand is a <strong>linear</strong>, <strong>smooth</strong> and
<strong>non-periodic</strong> function. In numerical algorithms like division, the goal isn&rsquo;t
necessarily the smallest average error, but guaranteeing the worst−case error
(∣ε₀∣) is as small as possible. This predictability is important because the
initial error directly determines the number of Newton-Raphson iterations
required to reach full machine precision. </p>
<p>We wish to calculate an approximation for this function such that the
<strong>worst-case error</strong> is minimal. The right tool for this job is the <a href="https://en.wikipedia.org/wiki/Equioscillation_theorem">Chebyshev
Equioscillation Theorem</a>. </p>
<p>Chebyshev approximation is used because it provides the
Best Uniform Approximation (or Minimax Approximation). This means that out of
all possible polynomials of a given degree, the Chebyshev method yields the one
that minimizes the maximum absolute error across the entire target interval.</p>
<p>We start with formulating the error function on whoch equioscillation will be
applied. The error function for figuring out the reciprocal <code>x₀ = 1/D</code> using a
simple straight line <code>x₀ = T₀ + T₁·D</code> (a linear equation) tells us how far off
our guess is from the perfect answer. Because we want the total result <code>D·x₀</code> to
be near <code>1</code>, we make the error function <code>f(D)</code> measure the difference between
that product and <code>1</code>. The formula is <code>f(D) = 1 - D·x₀</code>. When we plug in the
straight-line guess, the formula becomes: </p>
<div class="codehilite"><pre><span></span><code>f(D) = 1 - T₀·D - T₁·D²
</code></pre></div>

<p>The main goal is to pick the numbers <code>T₀</code> and <code>T₁</code> that make the absolute value
of this error <code>f(D)</code> as small as possible everywhere in the range. This is
exactly what the Chebyshev method does.</p>
<p>Before we apply the theorem on the error equation, we need to constrain the
values that <code>D</code> can take. Bounding D guarantees that the starting error is small
enough for the subsequent iterations to converge quickly and predictably to full
fixed-point precision. Without this bound, a much more complex, higher-degree
polynomial would be needed, defeating the efficiency goal. We bound <code>D</code> to be
<code>[0.5,1]</code>. In code, this scaling can be achieved through simple bit-shifts
(exemplified later in the code). As long as we scale the numerator too, we
should be good.</p>
<p>The theorem states that a polynomial is the best uniform approximation to a
continuous function over an interval if and only if the error function
alternates between its maximum positive and maximum negative values at least
(n+2) times, where <code>n</code> is the degree of the polynomial.</p>
<p>The theorem requires the maximum error to occur at the two endpoints (D=1/2 and
D=1) and the local extremum (Dmin) between them.  </p>
<p>The location of the local extremum is found by setting the derivative to zero:</p>
<div class="codehilite"><pre><span></span><code>F&#39;(D) = -T0 - 2T1 D = 0, which gives:
D_min = - T0 / (2T1)
</code></pre></div>

<p>The first condition of the theorem is that the error magnitude is equal at
endpoints i.e. </p>
<div class="codehilite"><pre><span></span><code>f(1/2) = f(1)

1 - T₀/2 - T₁/4 = 1 - T₀ - T₁ 
</code></pre></div>

<p>This simplifies to:</p>
<div class="codehilite"><pre><span></span><code>T₀ = - (3/2)·T₁
</code></pre></div>

<p>The second condition states that the error at endpoints must be the negative of
the error at the extremum i.e. </p>
<div class="codehilite"><pre><span></span><code>f(1) = -f(Dmin)
1 - T0 - T1 = - (1 + T0^2 / (4T1))
</code></pre></div>

<p>Substituing the value of T0 from above, </p>
<div class="codehilite"><pre><span></span><code><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="o">/</span><span class="mf">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">T1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="o">-</span><span class="mf">3</span><span class="o">/</span><span class="mf">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">T1</span><span class="p">)</span><span class="o">^</span><span class="mf">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">4</span><span class="n">T1</span><span class="p">))</span>
<span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span><span class="n">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mf">9</span><span class="n">T1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">16</span><span class="p">)</span>
</code></pre></div>

<p>Solving this linear equation for T1:</p>
<div class="codehilite"><pre><span></span><code><span class="mf">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">17</span><span class="n">T1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">16</span><span class="w"> </span>
<span class="n">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">32</span><span class="o">/</span><span class="mf">17</span>
</code></pre></div>

<p>Substituting T1 back into the original equation to find T0:</p>
<div class="codehilite"><pre><span></span><code>T0 = -(3/2) * (-32/17) 
T0 = 48/17
</code></pre></div>

<p>The resulting linear approximation is X0 = T0 + T1 D:</p>
<div class="codehilite"><pre><span></span><code>X0 = 48/17 - 32/17 * D
</code></pre></div>

<p>This equation gives us an initial estimate for the reciprocal that can be
refined by iterations of the NR equation that we found earlier.</p>
<h2>Implementation</h2>
<p>(A <a href="https://gist.github.com/bojle/60f9f9c0a7b0678a2f6b51553217ab6a">link</a> to the complete implementation)</p>
<p>The original rationale for doing this was two-fold:</p>
<ol>
<li>Lack of division circuitry.</li>
<li>Lack of support for floating point types.</li>
</ol>
<p>Lack of division circuitry has been dealt with through the design of the
algorithm above. Lack of floating point types can be dealt with by using
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">Fixed-Point notation</a>.
Fixed point allows us to get away with storing everything in integers and
operate using bit-shift operations, which tend to be cost efficient.</p>
<p>Here&rsquo;s an implementation of a fixed point types in C++:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdint&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;numeric&gt;</span>

<span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kr">int</span><span class="w"> </span><span class="n">FRAC_BITS</span><span class="p">,</span><span class="w"> </span><span class="kr">int</span><span class="w"> </span><span class="n">TOTAL_BITS</span><span class="o">&gt;</span>
<span class="kr">class</span><span class="w"> </span><span class="nc">FixedPoint</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">using</span><span class="w"> </span><span class="n">BaseType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decltype</span><span class="p">([]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">TOTAL_BITS</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kr">int8_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">TOTAL_BITS</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kr">int16_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">TOTAL_BITS</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kr">int32_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kr">int64_t</span><span class="p">{};</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}());</span>

<span class="w">    </span><span class="n">using</span><span class="w"> </span><span class="n">WideType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="p">(</span><span class="kr">sizeof</span><span class="p">(</span><span class="n">BaseType</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="kr">int64_t</span><span class="p">,</span><span class="w"> </span><span class="n">__int128_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="n">BaseType</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="kr">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">constexpr</span><span class="w"> </span><span class="kr">static</span><span class="w"> </span><span class="n">BaseType</span><span class="w"> </span><span class="n">SCALE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">static_cast</span><span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1ULL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">FRAC_BITS</span><span class="p">);</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="p">(</span><span class="kr">float</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="kr">static_cast</span><span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">round</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">SCALE</span><span class="p">)))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">BaseType</span><span class="w"> </span><span class="n">raw</span><span class="p">()</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kr">static</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="n">BaseType</span><span class="w"> </span><span class="n">rawVal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">FixedPoint</span><span class="w"> </span><span class="n">fp</span><span class="p">;</span>
<span class="w">        </span><span class="n">fp</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rawVal</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">float</span><span class="w"> </span><span class="n">toFloat</span><span class="p">()</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kr">static_cast</span><span class="o">&lt;</span><span class="kr">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">SCALE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="kr">operator</span><span class="o">+</span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="kr">operator</span><span class="o">-</span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="kr">operator</span><span class="o">*</span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">WideType</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">static_cast</span><span class="o">&lt;</span><span class="n">WideType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fromRaw</span><span class="p">(</span><span class="kr">static_cast</span><span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">prod</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">FRAC_BITS</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FixedPoint</span><span class="w"> </span><span class="kr">operator</span><span class="o">*</span><span class="p">(</span><span class="kr">float</span><span class="w"> </span><span class="n">factor</span><span class="p">)</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FixedPoint</span><span class="p">(</span><span class="n">toFloat</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factor</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">friend</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="kr">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fp</span><span class="p">.</span><span class="n">toFloat</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>The template parameters of this class are the split ratio of the underlying
fixed point type. This is fixed at compiler time for an instance of the type.
For example, <code>FixedPoint&lt;8,16&gt;</code> would mean the underlying type is a 16 bit
integer (<code>int16_t</code>) and the scale value would be <code>2^8</code> (<code>1 &lt;&lt; 8</code>). Additionally,
for convenience, we implement addition, substraction and multiplication.
The central idea that this class makes apparent is all <em>operations</em> are
performed on the integer directly and <em>conversion</em> involves scaling and
de-scaling with the scale value that stays constant.</p>
<p>We can now introduce the division algorithm in its entirety:</p>
<div class="codehilite"><pre><span></span><code><span class="n">using</span><span class="w"> </span><span class="n">Fx8_16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FixedPoint</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">Fx16_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FixedPoint</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">Fx8_16</span><span class="w"> </span><span class="n">fxdiv_corrected</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">assert</span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s2">&quot;Divide by zero undefined&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Fx8_16</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>

<span class="w">    </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">result_is_negative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="n">uint32_t</span><span class="w"> </span><span class="n">nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="n">uint32_t</span><span class="w"> </span><span class="n">dv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">Normalization</span><span class="o">/</span><span class="n">scaling</span><span class="w"> </span><span class="s1">&#39;d&#39;</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fit</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="mf">1.0</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">countl_zero</span><span class="o">&lt;</span><span class="n">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dv</span><span class="p">);</span>
<span class="w">    </span><span class="n">uint32_t</span><span class="w"> </span><span class="n">scaled_val_raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span>
<span class="w">    </span><span class="n">uint32_t</span><span class="w"> </span><span class="n">scaled_val_n_raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nv</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">;</span>
<span class="w">    </span><span class="n">constexpr</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">INTERPRETATION_SHIFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">d_scaled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fx16_32</span><span class="p">::</span><span class="n">fromRaw</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scaled_val_raw</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">INTERPRETATION_SHIFT</span><span class="p">));</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">n_scaled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fx16_32</span><span class="p">::</span><span class="n">fromRaw</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scaled_val_n_raw</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">INTERPRETATION_SHIFT</span><span class="p">));</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="n">Initial</span><span class="w"> </span><span class="n">approximate</span><span class="w"> </span><span class="n">calculation</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="mf">2.8235294</span><span class="n">f</span><span class="p">};</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">48</span><span class="o">/</span><span class="mi">17</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="mf">1.8823529</span><span class="n">f</span><span class="p">};</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">32</span><span class="o">/</span><span class="mi">17</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">initial_approx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d_scaled</span><span class="p">);</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="n">Newton</span><span class="o">-</span><span class="n">Raphson</span><span class="w"> </span><span class="n">iterations</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_approx</span><span class="p">;</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.</span><span class="n">f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">E1</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.</span><span class="n">f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">E2</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.</span><span class="n">f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">E3</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Fx16_32</span><span class="p">{</span><span class="mf">2.</span><span class="n">f</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">d_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">E4</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="mf">4.</span><span class="w"> </span><span class="n">Multiplication</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">Numerator</span>
<span class="w">    </span><span class="n">Fx16_32</span><span class="w"> </span><span class="n">res_16_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_scaled</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result_is_negative</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">Simple</span><span class="w"> </span><span class="n">negation</span><span class="w"> </span><span class="p">(</span><span class="n">assumes</span><span class="w"> </span><span class="n">FixedPoint</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">working</span><span class="w"> </span><span class="n">negation</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">multiply</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">res_16_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res_16_32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Truncate</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">Fx16_32</span><span class="w"> </span><span class="p">(</span><span class="n">FRAC_BITS</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">Fx8_16</span><span class="w"> </span><span class="p">(</span><span class="n">FRAC_BITS</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="w">    </span><span class="n">constexpr</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">TRUNCATION_SHIFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">raw</span><span class="w"> </span><span class="mi">32</span><span class="o">-</span><span class="n">bit</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">position</span>
<span class="w">    </span><span class="n">int32_t</span><span class="w"> </span><span class="n">raw_final_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res_16_32</span><span class="o">.</span><span class="n">raw</span><span class="p">();</span>
<span class="w">    </span><span class="n">int16_t</span><span class="w"> </span><span class="n">raw_final_16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">int16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw_final_32</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">TRUNCATION_SHIFT</span><span class="p">);</span>

<span class="w">    </span><span class="n">Fx8_16</span><span class="w"> </span><span class="n">final_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fx8_16</span><span class="p">::</span><span class="n">fromRaw</span><span class="p">(</span><span class="n">raw_final_16</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">final_res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>The algorithm had 4 parts: Normalization, Initial Approximation, NR Iterations,
Multiplication with Numerator. These are quite evident in the function above.
For intermidiate calculations, we use <code>FixedPoint&lt;16,32&gt;</code>, final results are in
<code>FixedPoint&lt;8,16&gt;</code>. There&rsquo;s something peculiar and previously un-explained in
this code: <code>INTERPRETATION_SHIFT</code> and <code>TRUNCATION_SHIFT</code>. These are there to
account for <strong>correctly lining up the decimal points</strong> at the start and the end
of the calculation.</p>
<p>The <strong>INTERPRETATION_SHIFT</strong> fixes the input value. When the divisor D is
normalized, the number is secretly set up with 31 digits after the decimal
(Q1.31). Since our math is being done in the Q15.16 format (only 16 digits after
the decimal), we have to move the value&rsquo;s decimal point to the left by <strong>15
positions</strong> (31 - 16). This right-shift makes sure the normalized input is read
as a number between 0.5 and 1.0, not as a very large integer.</p>
<p>The <strong>TRUNCATION_SHIFT</strong> manages the final output. The math produces a
high-precision number in the Q15.16 format. But the function needs to return the
result in the lower precision Q7.8 format (8 fractional bits). To shrink the
result to fit, we must move the decimal point left by <strong>8 positions</strong> (16 - 8).
This right-shift throws away the extra low-precision bits so the result matches
the final output type.</p>
<p>Let&rsquo;s compile and run this on an example:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">Fx8_16</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fxdiv_corrected</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Approximate division of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Real division of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>clang++<span class="w"> </span>fixed_div.cpp<span class="w"> </span>-o<span class="w"> </span>a<span class="w"> </span>-std<span class="o">=</span>c++20
$<span class="w"> </span>./a
Approximate<span class="w"> </span>division<span class="w"> </span>of<span class="w"> </span><span class="m">3</span>/4:<span class="w"> </span><span class="m">0</span>.74609375
Real<span class="w"> </span>division<span class="w"> </span>of<span class="w"> </span><span class="m">3</span>/4:<span class="w"> </span><span class="m">0</span>.75
</code></pre></div>

<p>Voila! 3 divided by 4 by our method results in <code>0.74609375</code> which is not that
far from the actual answer of <code>0.75</code>.</p>
<h2>Optimizations</h2>
<p>What has been implemented is quite reasonable, but it can be optimized further. </p>
<ol>
<li>Power-of-Two Denominator Shortcut</li>
</ol>
<p>When the denominator d is a power of two (+/- 2^k), the division N/D simplifies
to a bit shift. This avoids the entire costly iterative Newton-Raphson loop.
Detecting if an integer is a power of 2 can be done in constant time. One can
put this check right at the top of the function an drastically speed up
power-of-two divisions.</p>
<ol>
<li>Exploiting quadratic convergence and fraction length of resultant&rsquo;s type.</li>
</ol>
<p>One property of NR iteration is <strong>Quadratic Convergence</strong>. In lay terms, every
iteration of the invocation of the Newton-Raphson formula, the number of correct
bits in the result roughly double. After first iteration, 2 bits are correct,
after second, 4, after third 8. Thus we have a rough idea of how many iterations
would be required for a given type. The optimization here is to skip NR
iterations on the basis of FRACTION_LENGTH of the resultant type. We can use
<a href="https://en.cppreference.com/w/cpp/language/if.html">constexpr if</a> statements to
make sure the checks for type length do not affect runtime performance.</p>
<ol>
<li>Using a different method to find initial approximation.</li>
</ol>
<p>The <a href="https://en.wikipedia.org/wiki/Remez_algorithm">Remex algorithm</a> can, in
theory, generate better approximations using a higher-degree polynomial. The
tradeoff in this case would be extra cycles to calculate the initial
approximation at the benefit of not having to do as many NR iterations.</p>
<p>There are many more that I&rsquo;ve missed out. Recent
<a href="https://dl.acm.org/doi/pdf/10.1145/3708472">research</a> propose optimization to
the chebyshev approximation method that we used above using look-up tables and
magic constants. Moreover, alternative methods such as
<a href="https://en.wikipedia.org/wiki/CORDIC">CORDIC</a> can also be tried.</p>
<h2>Conclusion</h2>
<p>This article came into being after I spent around a month trying to understand
approximation methods and getting code for it to work. The actual code was
contributed to the <a href="https://github.com/llvm/llvm-project/">llvm-project</a> as an
addition to the stdfix library in the llvm libc project. Here is the
<a href="https://github.com/llvm/llvm-project/pull/154914">PR</a>.
<a href="https://github.com/llvm/llvm-project/blob/7eee67202378932d03331ad04e7d07ed4d988381/libc/src/__support/fixed_point/fx_bits.h#L242">Here&rsquo;s</a>
a link to the complete division function implemented with stdfix primitives and
the optimizations mentioned above.</p>
<p>For reporting any errors or asking questions, please contact me through any of
my socials mentioned on the <strong>About</strong> page :)</p>


    </main>

    <footer>
      <p>This website was built with <a href="https://github.com/venthur/blag">blag</a>.
      <br>
      Subscribe to the <a href="/atom.xml">atom feed</a>.
      <br>
      © 2025, Shreeyash Pandey 
      </p>
    </footer>
  </body>

</html>